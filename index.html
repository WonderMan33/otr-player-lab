<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Old Time Radio Archive ‚Äî hosted by Golden Radio Hour</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ccircle cx='50' cy='50' r='46' fill='%23d7b24a'/%3E%3Ctext x='50' y='64' font-size='52' text-anchor='middle'%3E%F0%9F%93%BB%3C/text%3E%3C/svg%3E" />
  <style>
    :root{
      --bg0:#070707;
      --bg1:#0d0d0d;
      --glass: rgba(0,0,0,.38);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --gold: #f5c24b;
      --gold2:#d7b24a;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1000px 600px at 20% 10%, rgba(245,194,75,.16), transparent 60%),
        radial-gradient(1000px 600px at 80% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }
    .wrap{
      width:min(1100px, 94vw);
      margin: 18px auto 30px;
    }
    header{
      display:flex;
      gap:14px;
      align-items:center;
      justify-content:space-between;
      padding: 14px 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      border-radius: 18px;
      backdrop-filter: blur(8px);
    }
    .brand{
      display:flex; gap:12px; align-items:center;
    }
    .logo{
      width:40px;height:40px;border-radius:14px;
      display:grid;place-items:center;
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.22), rgba(0,0,0,.55));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 30px rgba(0,0,0,.40);
      font-size:20px;
    }
    .brand h1{
      margin:0;
      font-size: 16px;
      letter-spacing:.6px;
      font-weight: 700;
    }
    .brand .sub{
      margin-top:2px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing:.4px;
    }

    /* Root mode pills */
    .modePills{
      display:flex;
      justify-content:center;
      gap:14px;
      margin: 14px auto 10px;
      flex-wrap:wrap;
    }
    .pillBtn{
      padding: 12px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.18), rgba(0,0,0,.38) 55%, rgba(0,0,0,.55));
      color: rgba(255,255,255,.92);
      cursor:pointer;
      font-size: 14px;
      letter-spacing: .8px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.10), 0 8px 24px rgba(0,0,0,.35);
      user-select:none;
    }
    .pillBtn:hover{ border-color: rgba(245,194,75,.55); }
    .pillBtn.active{
      border-color: rgba(245,194,75,.85);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.10),
                  0 0 0 3px rgba(245,194,75,.12),
                  0 10px 30px rgba(0,0,0,.40);
    }

    /* Player card */
    .card{
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      border-radius: 20px;
      padding: 14px;
      backdrop-filter: blur(8px);
      box-shadow: 0 18px 40px rgba(0,0,0,.35);
    }
    .topRow{
      display:flex;
      gap:14px;
      align-items:stretch;
      flex-wrap:wrap;
    }
    .now{
      flex: 1 1 420px;
      min-width: 280px;
    }
    .viz{
      flex: 1.4 1 520px;
      min-width: 280px;
      position:relative;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      overflow:hidden;
      background: rgba(0,0,0,.20);
    }
    canvas{ display:block; width:100%; height: 360px; }
    .vizOverlay{
      position:absolute; inset:0;
      pointer-events:none;
      background: radial-gradient(700px 250px at 50% 0%, rgba(245,194,75,.13), transparent 60%);
    }

    .titleLine{
      font-weight: 800;
      letter-spacing: .4px;
      font-size: 14px;
      margin: 2px 0 6px;
    }
    .metaLine{
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 12px;
      min-height: 16px;
    }
    .playerRow{
      display:flex;
      align-items:flex-end;
      gap:12px;
    }
    .controls{
      flex:1;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      background: rgba(0,0,0,.18);
    }
    .btnRow{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .btn{
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      cursor:pointer;
      font-size: 13px;
      letter-spacing: .5px;
      user-select:none;
    }
    .btn:hover{ border-color: rgba(245,194,75,.55); }
    .btn.primary{
      border-color: rgba(245,194,75,.70);
      background: rgba(245,194,75,.12);
    }
    .timeRow{
      display:flex;
      align-items:center;
      gap:10px;
      font-size: 12px;
      color: var(--muted);
    }
    .range{
      width:100%;
      accent-color: var(--gold);
    }

    /* Vertical volume */
    .volRail{
      width: 52px;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 8px 6px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      background: rgba(0,0,0,.18);
    }
    .volMain{
      height: 150px;
      width: 28px;
      writing-mode: vertical-lr;
      direction: rtl;
      accent-color: var(--gold);
    }

    /* Channel dock */
    nav.dock{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .dockBtn{
      padding: 11px 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.14), rgba(0,0,0,.42) 60%, rgba(0,0,0,.55));
      color: rgba(255,255,255,.92);
      cursor:pointer;
      font-size: 13px;
      letter-spacing: .6px;
      user-select:none;
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08);
    }
    .dockBtn.active{
      border-color: rgba(245,194,75,.85);
      box-shadow: inset 0 1px 0 rgba(255,255,255,.08), 0 0 0 3px rgba(245,194,75,.12);
    }

    /* Show mode panel */
    .showPanel{
      margin: 12px auto 0;
      max-width: 820px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      background: rgba(0,0,0,.18);
      padding: 12px;
    }
    .row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:center;
    }
    select.select{
      width: min(560px, 100%);
      max-width: 560px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.30);
      color: var(--text);
      font-size: 14px;
    }
    .smallNote{
      margin-top: 8px;
      text-align:center;
      font-size: 12px;
      color: var(--muted);
    }
    .episodeBox{
      margin-top: 10px;
      max-height: 340px;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 6px;
      border-top: 1px solid rgba(255,255,255,.08);
    }
    .epRow{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      cursor:pointer;
      display:flex;
      gap:12px;
      justify-content:space-between;
      align-items:flex-start;
    }
    .epRow:hover{ background: rgba(255,255,255,.03); }
    .epRow.active{ background: rgba(245,194,75,.10); }
    .epTitle{ font-size: 13px; font-weight: 700; }
    .epMeta{ font-size: 12px; color: var(--muted); white-space:nowrap; }

    /* Visualizer buttons */
    .vizStrip{
      display:flex;
      justify-content:center;
      gap:8px;
      flex-wrap:wrap;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
    }
    .vizBtn{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.90);
      cursor:pointer;
      font-size: 13px;
      user-select:none;
    }
    .vizBtn.active{ border-color: rgba(245,194,75,.80); }

    footer{
      margin-top: 14px;
      text-align:center;
      font-size: 12px;
      color: var(--muted);
    }
  
    /* Fullscreen overlay */
    .fsOverlay{
      position: fixed;
      inset: 0;
      z-index: 9999;
      background:
        radial-gradient(1200px 800px at 30% 10%, rgba(245,194,75,.18), transparent 60%),
        radial-gradient(1200px 800px at 80% 20%, rgba(255,255,255,.06), transparent 60%),
        linear-gradient(180deg, #050505, #0b0b0b);
    }
    .fsCanvasWrap{
      position:absolute;
      inset:0;
    }
    #fsCanvas{
      width:100%;
      height:100%;
      display:block;
    }
    .fsControls{
      position:absolute;
      left:0; right:0;
      bottom:0;
      padding: 14px 14px 18px;
      background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.72) 45%, rgba(0,0,0,.86));
      border-top: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
    }
    .fsTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .fsNow{
      font-size: 14px;
      font-weight: 800;
      letter-spacing: .5px;
      color: rgba(255,255,255,.92);
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 72vw;
    }
    .fsButtons{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .fsBtn{
      padding: 12px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.28);
      color: rgba(255,255,255,.92);
      cursor:pointer;
      font-size: 14px;
      letter-spacing: .6px;
      user-select:none;
    }
    .fsBtn:hover{ border-color: rgba(245,194,75,.65); }
    .fsPrimary{
      border-color: rgba(245,194,75,.85);
      background: rgba(245,194,75,.14);
    }
    .fsSeek{
      width: min(900px, 92vw);
      display:block;
      margin: 0 auto 10px;
      accent-color: var(--gold);
    }
    .fsBottom{
      display:flex;
      gap:14px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      max-width: 1100px;
      margin: 0 auto;
    }
    .fsTime{
      font-size: 13px;
      color: rgba(255,255,255,.78);
      letter-spacing: .4px;
    }
    .fsVol{
      display:flex;
      align-items:center;
      gap:8px;
      color: rgba(255,255,255,.78);
      font-size: 13px;
    }
    .fsVolSlider{
      width: 180px;
      accent-color: var(--gold);
    }
    .fsVizStrip{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .fsVizBtn.active{
      border-color: rgba(245,194,75,.85);
      box-shadow: 0 0 0 3px rgba(245,194,75,.12);
    }

  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">üìª</div>
        <div>
          <h1>Old Time Radio Archive</h1>
          <div class="sub">hosted by Golden Radio Hour</div>
        </div>
      </div>
      
    </header>

    <div class="modePills" id="modePills">
      <button class="pillBtn active" id="pillListenChannel" type="button">Listen to Channel</button>
      <button class="pillBtn" id="pillListenShow" type="button">Listen by Show</button>
    </div>

    <div class="card">
      <div class="topRow">
        <div class="now">
          <div class="titleLine" id="nowTitle">Loading‚Ä¶</div>
          <div class="metaLine" id="nowMeta"> </div>

          <div class="playerRow">
            <div class="controls">
              <div class="btnRow">
                <button class="btn" id="btnPrev" type="button">‚üµ Prev</button>
                <button class="btn primary" id="btnPlay" type="button">Play</button>
                <button class="btn" id="btnNext" type="button">Next ‚ü∂</button>
                <button class="btn" id="btnStop" type="button">Stop</button>
              </div>

              <input class="range" id="seek" type="range" min="0" max="1000" value="0" />

              <div class="timeRow">
                <div id="tCur">0:00</div>
                <div style="flex:1"></div>
                <div id="tDur">0:00</div>
              </div>
            </div>

            <div class="volRail" title="Volume">
              <input id="volMain" class="volMain" type="range" min="0" max="1" step="0.01" value="0.6" aria-label="Volume" />
            </div>
          </div>

          <nav class="dock" id="dock" aria-label="Channels"></nav>
        </div>

        <div class="viz">
          <canvas id="vizCanvas" width="900" height="300"></canvas>
          <div class="vizOverlay"></div>

          <div class="vizStrip" id="vizStrip">
  <button class="vizBtn" id="vizFullscreenBtn" type="button">Fullscreen</button>
            <button class="vizBtn active" data-viz="none" type="button">Off</button>
            <button class="vizBtn" data-viz="wave" type="button">Wave</button>
            <button class="vizBtn" data-viz="bars" type="button">Bars</button>
            <button class="vizBtn" data-viz="ring" type="button">Ring</button>
            <button class="vizBtn" data-viz="particles" type="button">Particles</button>
          </div>
        </div>
      </div>

      <div class="showPanel" id="showPanel" style="display:none;">
        <div class="row">
          <select id="showSelectInline" class="select">
            <option value="__all__">Select a show‚Ä¶</option>
          </select>
        </div>
        <div class="smallNote">Pick a show to start (no autoplay until you choose). Then use Prev/Next to skip episodes.</div>
        <div class="episodeBox" id="episodeBox"></div>
      </div>
    </div>

    <footer>
      Tip: If you prefer browsing by program, tap <b>Listen by Show</b>. For easy ‚Äúradio-style‚Äù listening, tap <b>Listen to Channel</b>.
    </footer>
  </div>

  
  <!-- Fullscreen Visualizer Overlay -->
  <div id="fsOverlay" class="fsOverlay" style="display:none;" aria-hidden="true">
    <div class="fsCanvasWrap">
      <canvas id="fsCanvas"></canvas>
    </div>

    <div class="fsControls">
      <div class="fsTop">
        <div class="fsNow" id="fsNow">Now Playing</div>
        <button class="fsBtn" id="fsExitBtn" type="button">Exit Fullscreen</button>
      </div>

      <div class="fsButtons">
        <button class="fsBtn" id="fsPrev" type="button">‚üµ Prev</button>
        <button class="fsBtn fsPrimary" id="fsPlay" type="button">Play</button>
        <button class="fsBtn" id="fsNext" type="button">Next ‚ü∂</button>
        <button class="fsBtn" id="fsStop" type="button">Stop</button>
      </div>

      <input class="fsSeek" id="fsSeek" type="range" min="0" max="1000" value="0" />

      <div class="fsBottom">
        <div class="fsTime">
          <span id="fsTCur">0:00</span>
          <span> / </span>
          <span id="fsTDur">0:00</span>
        </div>

        <div class="fsVol">
          <span class="fsVolLabel">Vol</span>
          <input id="fsVol" class="fsVolSlider" type="range" min="0" max="1" step="0.01" value="0.6" aria-label="Volume" />
        </div>

        <div class="fsVizStrip" id="fsVizStrip">
          <button class="fsBtn fsVizBtn active" data-viz="none" type="button">Off</button>
          <button class="fsBtn fsVizBtn" data-viz="wave" type="button">Wave</button>
          <button class="fsBtn fsVizBtn" data-viz="bars" type="button">Bars</button>
          <button class="fsBtn fsVizBtn" data-viz="ring" type="button">Ring</button>
          <button class="fsBtn fsVizBtn" data-viz="particles" type="button">Particles</button>
        </div>
      </div>
    </div>
  </div>


  <audio id="audio" preload="none" crossorigin="anonymous"></audio>

  <script>
  "use strict";

  // ---------- helpers ----------
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function escapeHtml(str){
    return String(str ?? "")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }
  function safeShow(el, on){
    if(!el) return;
    el.style.display = on ? "" : "none";
  }
  function fmtTime(sec){
    sec = Math.max(0, Math.floor(sec || 0));
    const m = Math.floor(sec/60);
    const s = sec%60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  // ---------- DOM ----------
  const pillListenChannel = document.getElementById("pillListenChannel");
  const pillListenShow = document.getElementById("pillListenShow");
  const dock = document.getElementById("dock");
  const showPanel = document.getElementById("showPanel");
  const showSelectInline = document.getElementById("showSelectInline");
  const episodeBox = document.getElementById("episodeBox");

  const nowTitle = document.getElementById("nowTitle");
  const nowMeta  = document.getElementById("nowMeta");

  const btnPrev = document.getElementById("btnPrev");
  const btnPlay = document.getElementById("btnPlay");
  const btnNext = document.getElementById("btnNext");
  const btnStop = document.getElementById("btnStop");

  const seek = document.getElementById("seek");
  const tCur = document.getElementById("tCur");
  const tDur = document.getElementById("tDur");
  const volMain = document.getElementById("volMain");

  const audioEl = document.getElementById("audio");
  
  // Fullscreen elements (declared early to avoid TDZ)
  var fsOverlay=null, fsCanvas=null, fsExitBtn=null, fsNow=null, fsPrev=null, fsPlay=null, fsNext=null, fsStop=null, fsSeek=null, fsTCur=null, fsTDur=null, fsVol=null, fsVizStrip=null;
  var inFullscreen=false;

  audioEl.volume = Number(volMain.value || 0.6);

  // ---------- app state ----------
  let mode = "channel"; // "channel" | "show"
  let allTracks = [];
  let showIndex = new Map(); // showKey -> {name, tracks}
  let currentShowKey = null;
  let currentQueue = [];     // playing queue in current mode
  let currentIdx = -1;       // index within currentQueue
  let currentKey = "";       // for episode highlight in show list

  // Channels are heuristic because your JSON currently has no tags.
  const CHANNELS = [
    { id:"detective", label:"Detective",  test: s => /detective|sleuth|noir|private|marlowe|falcon|regan|diamond|wolfe|dollar|drew|broadway|beat/i.test(s) },
    { id:"mystery",   label:"Mystery",    test: s => /mystery|whistler|murder|case|investigation/i.test(s) },
    { id:"suspense",  label:"Suspense",   test: s => /suspense|terror|thriller/i.test(s) },
    { id:"horror",    label:"Horror",     test: s => /horror|haunt|ghost|vamp|demon|weird|night|dark/i.test(s) },
    { id:"scifi",     label:"Sci‚ÄëFi",     test: s => /x minus|x\-minus|science|space|planet|alien|robot|twilight|zone/i.test(s) },
    { id:"western",   label:"Western",    test: s => /gunsmoke|six shooter|ranger|west|cowboy|texas/i.test(s) },
    { id:"comedy",    label:"Comedy",     test: s => /comedy|molly|mcgee|jack benny|burns|allen|lucille|abbott|costello/i.test(s) },
    { id:"theater",   label:"Radio Theater", test: s => /radio mystery theater|cbs radio|playhouse|theater|theatre/i.test(s) },
    { id:"all",       label:"All",        test: _ => true },
  ];

  let currentChannelId = "detective";

  // ---------- mode switching (ROOT PILLS) ----------
  function setModeFromUI(newMode){
    mode = newMode;
    pillListenChannel.classList.toggle("active", mode === "channel");
    pillListenShow.classList.toggle("active", mode === "show");
    safeShow(dock, mode === "channel");
    safeShow(showPanel, mode === "show");
    // Do NOT autoplay when switching into show mode.
    updateNowPlayingUI();
  }

  pillListenChannel.addEventListener("click", () => setModeFromUI("channel"));
  pillListenShow.addEventListener("click", () => setModeFromUI("show"));

  // ---------- build indexes ----------
  function normShowName(t){
    return (t.showTitle || t.show || "").trim();
  }
  function buildShowIndex(){
    showIndex = new Map();
    for(const t of allTracks){
      const key = (t.show || normShowName(t)).toLowerCase();
      if(!showIndex.has(key)){
        showIndex.set(key, { key, name: normShowName(t) || t.show || "Unknown", tracks: [] });
      }
      showIndex.get(key).tracks.push(t);
    }
    // Optional sort for stability
    for(const v of showIndex.values()){
      v.tracks.sort((a,b) => String(a.displayTitle||a.title||"").localeCompare(String(b.displayTitle||b.title||"")));
    }
  }

  function populateShowSelect(){
    const items = Array.from(showIndex.values())
      .sort((a,b) => a.name.localeCompare(b.name))
      .map(v => ({ value: v.key, label: v.name }));

    showSelectInline.innerHTML = `<option value="__all__">Select a show‚Ä¶</option>` +
      items.map(it => `<option value="${escapeHtml(it.value)}">${escapeHtml(it.label)}</option>`).join("");
  }

  // ---------- channels ----------
  function buildChannelQueue(channelId){
    const ch = CHANNELS.find(x => x.id === channelId) || CHANNELS[CHANNELS.length-1];
    // Choose representative text for classification
    const tracks = allTracks.filter(t => ch.test(`${normShowName(t)} ${t.title||""}`));
    // Shuffle lightly (Fisher-Yates)
    const arr = tracks.slice();
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  function renderDock(){
    dock.innerHTML = "";
    for(const ch of CHANNELS){
      if(ch.id === "all") continue; // keep All but place at end visually
    }
    const ordered = [...CHANNELS.filter(c=>c.id!=="all"), CHANNELS.find(c=>c.id==="all")].filter(Boolean);

    ordered.forEach(ch => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "dockBtn" + (ch.id === currentChannelId ? " active" : "");
      b.textContent = ch.label;
      b.addEventListener("click", () => {
        currentChannelId = ch.id;
        Array.from(dock.querySelectorAll(".dockBtn")).forEach(x => x.classList.remove("active"));
        b.classList.add("active");

        // Switch to channel mode and start playing immediately (radio behavior)
        setModeFromUI("channel");
        currentQueue = buildChannelQueue(currentChannelId);
        currentIdx = 0;
        playIndex(currentIdx, true);
      });
      dock.appendChild(b);
    });
  }

  // ---------- show mode rendering ----------
  function renderEpisodes(){
    episodeBox.innerHTML = "";
    if(!currentShowKey){
      episodeBox.innerHTML = `<div style="padding:12px;color:rgba(255,255,255,.70)">Pick a show to see episodes.</div>`;
      return;
    }
    const group = showIndex.get(currentShowKey);
    if(!group || !group.tracks.length){
      episodeBox.innerHTML = `<div style="padding:12px;color:rgba(255,255,255,.70)">No episodes found for this show.</div>`;
      return;
    }
    group.tracks.forEach((t, idx) => {
      const key = `show|${currentShowKey}|${idx}`;
      const row = document.createElement("div");
      row.className = "epRow" + (key === currentKey ? " active" : "");
      row.innerHTML = `<div class="epTitle">${escapeHtml(t.displayTitle || t.title || "Untitled")}</div>
                       <div class="epMeta">${t.durationSeconds ? escapeHtml(fmtTime(t.durationSeconds)) : ""}</div>`;
      row.addEventListener("click", () => {
        currentQueue = group.tracks;
        currentIdx = idx;
        currentKey = key;
        highlightEpisode();
        playIndex(currentIdx, true);
      });
      episodeBox.appendChild(row);
    });
  }

  function highlightEpisode(){
    episodeBox.querySelectorAll(".epRow").forEach(r => r.classList.remove("active"));
    const match = episodeBox.querySelector(`.epRow[data-key="${CSS.escape(currentKey)}"]`);
    if(match) match.classList.add("active");
  }

  showSelectInline.addEventListener("change", () => {
    const v = showSelectInline.value;
    if(!v || v === "__all__"){
      currentShowKey = null;
      currentQueue = [];
      currentIdx = -1;
      currentKey = "";
      renderEpisodes();
      updateNowPlayingUI();
      return;
    }
    currentShowKey = v;
    // Show mode should be visible; no autoplay until selection (but selecting a show is the user action)
    setModeFromUI("show");
    currentQueue = showIndex.get(currentShowKey)?.tracks || [];
    currentIdx = -1; // do not start until user clicks an episode OR presses Play
    currentKey = "";
    renderEpisodes();
    updateNowPlayingUI();
  });

  // ---------- audio control ----------
  let userSeeking = false;

  function setPlayButton(isPlaying){
    btnPlay.textContent = isPlaying ? "Pause" : "Play";
    if(typeof fsPlay !== "undefined" && fsPlay) fsPlay.textContent = isPlaying ? "Pause" : "Play";
  }

  function updateNowPlayingUI(){
    if(mode === "channel"){
      const name = (CHANNELS.find(c=>c.id===currentChannelId)?.label) || "Channel";
      nowTitle.textContent = currentQueue[currentIdx]?.displayTitle || currentQueue[currentIdx]?.title || `Channel: ${name}`;
      nowMeta.textContent = `Channel: ${name}`;
      if(typeof fsNow !== "undefined" && fsNow) fsNow.textContent = nowTitle.textContent;
    }else{
      const showName = currentShowKey ? (showIndex.get(currentShowKey)?.name || "Show") : "Show";
      const t = currentQueue[currentIdx];
      nowTitle.textContent = t ? (t.displayTitle || t.title || "Untitled") : `Show: ${showName}`;
      nowMeta.textContent = `Show mode: ${showName}`;
      if(typeof fsNow !== "undefined" && fsNow) fsNow.textContent = nowTitle.textContent;
    }
  }

  function loadTrack(t){
    if(!t){
      audioEl.removeAttribute("src");
      audioEl.load();
      return;
    }
    audioEl.src = t.url;
    audioEl.load();
    updateNowPlayingUI();
  }

  async function playIndex(idx, autoplay){
    idx = clamp(idx, 0, Math.max(0, currentQueue.length-1));
    currentIdx = idx;
    const t = currentQueue[currentIdx];
    loadTrack(t);

    if(mode === "show" && currentShowKey){
      currentKey = `show|${currentShowKey}|${currentIdx}`;
      // highlight
      episodeBox.querySelectorAll(".epRow").forEach((r,i) => {
        const on = i === currentIdx;
        r.classList.toggle("active", on);
        if(on) r.scrollIntoView({block:"nearest"});
      });
    }

    if(autoplay){
      try{
        await audioEl.play();
        setPlayButton(true);
      }catch(e){
        // autoplay blocked; keep button as Play
        setPlayButton(false);
      }
    }else{
      setPlayButton(false);
    }
  }

  function stopPlayback(){
    audioEl.pause();
    audioEl.currentTime = 0;
    setPlayButton(false);
  }

  btnPlay.addEventListener("click", async () => {
    if(!audioEl.src){
      // If in channel mode with no queue started yet, start at current channel
      if(mode === "channel"){
        currentQueue = buildChannelQueue(currentChannelId);
        currentIdx = 0;
        await playIndex(currentIdx, true);
        return;
      }
      // In show mode: require a show selected + either an episode click or start from first
      if(mode === "show" && currentShowKey){
        currentQueue = showIndex.get(currentShowKey)?.tracks || [];
        if(!currentQueue.length) return;
        if(currentIdx < 0) currentIdx = 0;
        await playIndex(currentIdx, true);
        return;
      }
      return;
    }

    if(audioEl.paused){
      try{ await audioEl.play(); setPlayButton(true); }catch(e){ setPlayButton(false); }
    }else{
      audioEl.pause();
      setPlayButton(false);
    }
  });

  btnPrev.addEventListener("click", () => {
    if(!currentQueue.length) return;
    const next = (currentIdx <= 0) ? 0 : currentIdx - 1;
    playIndex(next, true);
  });

  btnNext.addEventListener("click", () => {
    if(!currentQueue.length) return;
    const next = (currentIdx >= currentQueue.length-1) ? currentQueue.length-1 : currentIdx + 1;
    playIndex(next, true);
  });

  btnStop.addEventListener("click", stopPlayback);

  volMain.addEventListener("input", () => {
    audioEl.volume = Number(volMain.value);
    if(typeof fsVol !== "undefined" && fsVol) fsVol.value = String(audioEl.volume);
  });

  audioEl.addEventListener("ended", () => {
    // Auto-advance
    if(!currentQueue.length) return;
    if(currentIdx < currentQueue.length-1){
      playIndex(currentIdx+1, true);
    }else{
      setPlayButton(false);
    }
  });

  audioEl.addEventListener("timeupdate", () => {
    if(userSeeking) return;
    const dur = audioEl.duration || 0;
    const cur = audioEl.currentTime || 0;
    tCur.textContent = fmtTime(cur);
    tDur.textContent = fmtTime(dur);
    if(typeof fsTCur !== "undefined"){ fsTCur.textContent = fmtTime(cur); fsTDur.textContent = fmtTime(dur); }
    if(dur > 0){
      seek.value = String(Math.floor((cur/dur)*1000));
      if(typeof fsSeek !== "undefined") fsSeek.value = seek.value;
    }else{
      seek.value = "0";
      if(typeof fsSeek !== "undefined") fsSeek.value = "0";
    }
  });

  seek.addEventListener("input", () => { userSeeking = true; });
  seek.addEventListener("change", () => {
    const dur = audioEl.duration || 0;
    if(dur > 0){
      const pct = Number(seek.value)/1000;
      audioEl.currentTime = dur * pct;
    }
    userSeeking = false;
  });
  // ---------- fullscreen visualizer (canvas fills screen + controls overlay) ----------
  const vizBox = document.querySelector(".viz");
  const vizFullscreenBtn = document.getElementById("vizFullscreenBtn");

  fsOverlay = document.getElementById("fsOverlay");
  fsCanvas = document.getElementById("fsCanvas");
  fsExitBtn = document.getElementById("fsExitBtn");
  fsNow = document.getElementById("fsNow");
  fsPrev = document.getElementById("fsPrev");
  fsPlay = document.getElementById("fsPlay");
  fsNext = document.getElementById("fsNext");
  fsStop = document.getElementById("fsStop");
  fsSeek = document.getElementById("fsSeek");
  fsTCur = document.getElementById("fsTCur");
  fsTDur = document.getElementById("fsTDur");
  fsVol = document.getElementById("fsVol");
  fsVizStrip = document.getElementById("fsVizStrip");
  function showFs(on){
    if(!fsOverlay) return;
    fsOverlay.style.display = on ? "block" : "none";
    fsOverlay.setAttribute("aria-hidden", on ? "false" : "true");
    inFullscreen = on;
    resizeCanvas();
    resizeFsCanvas();
  }

  function resizeFsCanvas(){
    const rect = fsCanvas.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    fsCanvas.width = Math.floor(rect.width * dpr);
    fsCanvas.height = Math.floor(rect.height * dpr);
    const fsCtx = fsCanvas.getContext("2d");
    fsCtx.setTransform(dpr,0,0,dpr,0,0);
  }

  window.addEventListener("resize", () => {
    if(inFullscreen) resizeFsCanvas();
  });

  vizFullscreenBtn?.addEventListener("click", async () => {
    try{
      if (!document.fullscreenElement) {
        showFs(true);
        await fsOverlay.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(e){
      console.error("Fullscreen failed:", e);
      showFs(false);
    }
  });

  fsExitBtn?.addEventListener("click", async () => {
    try{
      if(document.fullscreenElement) await document.exitFullscreen();
      else showFs(false);
    }catch(e){
      console.error(e);
      showFs(false);
    }
  });

  document.addEventListener("fullscreenchange", () => {
    const on = !!document.fullscreenElement;
    showFs(on);
  });

  // Mirror main controls into fullscreen overlay
  function syncFsButtons(){
    fsPlay.textContent = audioEl.paused ? "Play" : "Pause";
    fsVol.value = String(audioEl.volume);
  }

  function syncFsNow(){
    // Copy main now-playing line
    fsNow.textContent = nowTitle.textContent || "Now Playing";
  }

  fsPrev?.addEventListener("click", () => btnPrev.click());
  fsNext?.addEventListener("click", () => btnNext.click());
  fsStop?.addEventListener("click", () => btnStop.click());
  fsPlay?.addEventListener("click", () => btnPlay.click());

  fsVol?.addEventListener("input", () => {
    audioEl.volume = Number(fsVol.value);
    volMain.value = fsVol.value;
  });

  fsSeek?.addEventListener("input", () => { userSeeking = true; });
  fsSeek?.addEventListener("change", () => {
    const dur = audioEl.duration || 0;
    if(dur > 0){
      const pct = Number(fsSeek.value)/1000;
      audioEl.currentTime = dur * pct;
    }
    userSeeking = false;
  });

  fsVizStrip?.querySelectorAll("[data-viz]")?.forEach(btn => {
    btn.addEventListener("click", () => {
      fsVizStrip.querySelectorAll("[data-viz]").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      const v = btn.getAttribute("data-viz");
      // keep both strips in sync
      vizStrip.querySelectorAll("[data-viz]").forEach(b => b.classList.toggle("active", b.getAttribute("data-viz") === v));
      setVisualizer(v);
    });
  });
  });


  // ---------- visualizer ----------
  const vizCanvas = document.getElementById("vizCanvas");
  const vctx = vizCanvas.getContext("2d");
  const vizStrip = document.getElementById("vizStrip");
  let vizMode = "none";
  let audioCtx = null;
  let analyser = null;
  let dataArr = null;
  let srcNode = null;
  let particles = [];

  function resizeCanvas(){
    // match CSS size while keeping internal resolution high enough
    const rect = vizCanvas.getBoundingClientRect();
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    vizCanvas.width = Math.floor(rect.width * dpr);
    vizCanvas.height = Math.floor(rect.height * dpr);
    vctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resizeCanvas);

  function ensureAudioGraph(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    dataArr = new Uint8Array(analyser.frequencyBinCount);
    srcNode = audioCtx.createMediaElementSource(audioEl);
    srcNode.connect(analyser);
    analyser.connect(audioCtx.destination);
  }

  function setVisualizer(modeName){
    vizMode = modeName;
  }

  vizStrip.querySelectorAll("[data-viz]").forEach(btn => {
    btn.addEventListener("click", () => {
      vizStrip.querySelectorAll("[data-viz]").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
      setVisualizer(btn.getAttribute("data-viz"));
    });
  });

  function draw(){
    requestAnimationFrame(draw);

    // draw to normal canvas
    drawTo(vizCanvas, vctx);

    // draw to fullscreen canvas if active
    if(typeof inFullscreen !== "undefined" && inFullscreen){
      if(fsCanvas){
      const fsCtx = fsCanvas.getContext("2d");
      drawTo(fsCanvas, fsCtx);
    }
    }
  }

  function drawTo(canvasEl, ctx){
    if(!ctx || !canvasEl) return;
    const rect = canvasEl.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    ctx.clearRect(0,0,w,h);

    // background
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.fillRect(0,0,w,h);

    if(vizMode === "none") return;

    ensureAudioGraph();
    if(audioCtx && audioCtx.state === "suspended" && !audioEl.paused){
      audioCtx.resume().catch(()=>{});
    }

    analyser.getByteFrequencyData(dataArr);

    if(vizMode === "bars"){
      const bars = 72;
      const step = Math.floor(dataArr.length / bars);
      const bw = w / bars;
      for(let i=0;i<bars;i++){
        const v = dataArr[i*step] / 255;
        const bh = v * (h*0.80);
        ctx.fillStyle = `rgba(245,194,75,${0.15 + v*0.75})`;
        ctx.fillRect(i*bw, h-bh, bw*0.70, bh);
      }
    }

    if(vizMode === "wave"){
      analyser.getByteTimeDomainData(dataArr);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(245,194,75,.85)";
      ctx.beginPath();
      for(let i=0;i<dataArr.length;i++){
        const x = (i/(dataArr.length-1))*w;
        const y = (dataArr[i]/255)*h;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    if(vizMode === "ring"){
      const cx = w/2, cy = h/2;
      const radius = Math.min(w,h)*0.22;
      const points = 140;
      ctx.beginPath();
      for(let i=0;i<points;i++){
        const idx = Math.floor(i*(dataArr.length/points));
        const amp = (dataArr[idx]/255) * (Math.min(w,h)*0.12);
        const a = (i/points) * Math.PI*2;
        const r = radius + amp;
        const x = cx + Math.cos(a)*r;
        const y = cy + Math.sin(a)*r;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.strokeStyle = "rgba(245,194,75,.85)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = "rgba(245,194,75,.10)";
      ctx.fill();
    }

    if(vizMode === "particles"){
      if(particles.length < 110){
        particles = Array.from({length:110}, () => ({
          x: Math.random()*w,
          y: Math.random()*h,
          vx: (Math.random()-.5)*0.7,
          vy: (Math.random()-.5)*0.7,
          r: 1 + Math.random()*2.2
        }));
      }
      const energy = dataArr.reduce((a,b)=>a+b,0) / (dataArr.length*255);
      for(const p of particles){
        p.x += p.vx*(1+energy*2.4);
        p.y += p.vy*(1+energy*2.4);
        if(p.x<0) p.x=w;
        if(p.x>w) p.x=0;
        if(p.y<0) p.y=h;
        if(p.y>h) p.y=0;
        ctx.beginPath();
        ctx.fillStyle = `rgba(245,194,75,${0.10 + energy*0.75})`;
        ctx.arc(p.x,p.y,p.r*(1+energy*1.7),0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  // Start draw loop after layout paint
  window.addEventListener("load", () => {
    resizeCanvas();
    requestAnimationFrame(draw);
  });

  // ---------- load JSON ----------
  async function loadShowsJson(){
    const url = "./shows.json";
    console.log("Trying JSON:", url);
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok) throw new Error("Failed to load shows.json: " + res.status);
    const json = await res.json();
    if(!Array.isArray(json)) throw new Error("shows.json is not an array");
    return json;
  }

  async function init(){
    // default UI
    setModeFromUI("channel");

    // load tracks
    allTracks = await loadShowsJson();
    console.log("Loaded tracks:", allTracks.length);

    buildShowIndex();
    populateShowSelect();
    renderDock();

    // Prime channel queue but don't autoplay until user presses Play or taps a channel
    currentQueue = buildChannelQueue(currentChannelId);
    currentIdx = -1;
    nowTitle.textContent = "Ready.";
    nowMeta.textContent = "Pick a channel, or switch to Show mode to browse programs.";
    tCur.textContent = "0:00";
    tDur.textContent = "0:00";
  }

  init().catch(err => {
    console.error(err);
    nowTitle.textContent = "Couldn‚Äôt load shows.json";
    nowMeta.textContent = String(err?.message || err);
  });
  </script>
</body>
</html>
